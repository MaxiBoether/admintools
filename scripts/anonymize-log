#!/bin/sh
''':'
exec python3 -OO "$0" "$@"
'''
# The above is a little hack to use arguments in the shebang.

__doc__ = '''\
This script is intended to anonymize log files.

Currently, IPv4, IPv6 and email addresses are considered.
False positives are more tolerable than false negatives.
Effectiveness over efficiency.

If you want to anonymize your logs with logrotate, you can place the
following lines in, e.g.,
``/etc/logrotate.d/000-anonymize-before-compression``:
``compress``,
``compresscmd /bin/sh``,
``compressoptions -c '/where/ever/anonymize-log | gzip'``.

This can, e.g., be useful to fulfill the General Data Protection
Regulation (GDPR, German: DSGVO).
'''



import argparse

from logging import getLogger, DEBUG, INFO, debug, info, error
from abc import ABCMeta, abstractmethod
from sys import stdin, stdout
from re import compile as compile_re, IGNORECASE
from tempfile import mkstemp
from shutil import copy
from os import remove, fdopen



class Cleaner(object):
  '''
  A sort of a job queue that holds jobs which should be run (in order)
  before the program exits.
  '''

  def __init__(self):
    ''' initializes instance variables '''
    self._jobs = []

  def add_job(self, func, *args, **kwargs):
    ''' add a job to the queue '''
    self._jobs.append((func, args, kwargs))

  def do_all_jobs(self):
    ''' do (and remove) all the jobs in (from) the queue '''
    while self._jobs:
      self.do_one_job()

  def do_one_job(self):
    ''' do and remove one job from the queue '''
    # in reverse order:
    func, args, kwargs = self._jobs.pop()
    debug("cleanup: func=%s.%s, args=%r, kwargs=%r", func.__module__,
          func.__name__, args, kwargs)
    func(*args, **kwargs)



class LineProcessorRegistry(object, metaclass=ABCMeta):
  '''
  Concrete subclasses of ``LineProcessorBase`` register at this class.
  '''
  items = set()
  register = items.add



class LineProcessorBase(object, metaclass=ABCMeta):
  '''
  A common base class for all line processors.
  '''

  def __init__(self, _):
    '''
    called initially, mainly to enable the addition of CLI arguments
    '''
    super().__init__()

  def setup(self, parsed_args):
    ''' called once prior checks (i.e. calls to ``process``) '''
    pass

  @abstractmethod
  def process(self, line):
    '''
    returns processed ``line``

    A general note on regular expressions: measurements (cPython 3)
    showed that it is generally cheaper to match with non-capturing
    regular expressions although the matches have to be processed another
    time afterwards. (Probably because the matching is way more often
    performed than anonymization.)
    '''
    pass



@LineProcessorRegistry.register
class Ipv4Processor(LineProcessorBase):
  ''' anonymizes IPv4 addresses by replacing the last octet with 'x' '''

  # thanks to https://stackoverflow.com/a/106223 (adapted)
  REGEXP = (
    r'(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\.'
    r'(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\.'
    r'(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\.'
    r'(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])'
  )

  def __init__(self, argparser):
    ''' see base class' documentation on ``__init__`` '''
    super().__init__(argparser)
    self.pattern = compile_re(self.__class__.REGEXP)

  def process(self, line):
    ''' returns processed ``line`` '''
    for match in self.pattern.finditer(line):
      matched_string = match.group(0)
      left_octets, _ = matched_string.rsplit('.', 1)
      replace_string = '%s.0' % left_octets
      line = line.replace(matched_string, replace_string, 1)

    return line



@LineProcessorRegistry.register
class Ipv6Processor(LineProcessorBase):
  '''
  anonymizes IPv6 addresses by replacing the right-most non-empty hextet
  with 'x'
  '''

  # thanks to https://gist.github.com/dfee/6ed3a4b05cfe7a6faf40a2102408d5d8
  REGEXP = r'(?:(?:(?:(?:[0-9a-fA-F]){1,4}):){1,4}:[^\s:](?:(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])))|(?:::(?:ffff(?::0{1,4}){0,1}:){0,1}[^\s:](?:(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])))|(?:fe80:(?::(?:(?:[0-9a-fA-F]){1,4})){0,4}%[0-9a-zA-Z]{1,})|(?::(?:(?::(?:(?:[0-9a-fA-F]){1,4})){1,7}|:))|(?:(?:(?:[0-9a-fA-F]){1,4}):(?:(?::(?:(?:[0-9a-fA-F]){1,4})){1,6}))|(?:(?:(?:(?:[0-9a-fA-F]){1,4}):){1,2}(?::(?:(?:[0-9a-fA-F]){1,4})){1,5})|(?:(?:(?:(?:[0-9a-fA-F]){1,4}):){1,3}(?::(?:(?:[0-9a-fA-F]){1,4})){1,4})|(?:(?:(?:(?:[0-9a-fA-F]){1,4}):){1,4}(?::(?:(?:[0-9a-fA-F]){1,4})){1,3})|(?:(?:(?:(?:[0-9a-fA-F]){1,4}):){1,5}(?::(?:(?:[0-9a-fA-F]){1,4})){1,2})|(?:(?:(?:(?:[0-9a-fA-F]){1,4}):){1,6}:(?:(?:[0-9a-fA-F]){1,4}))|(?:(?:(?:(?:[0-9a-fA-F]){1,4}):){1,7}:)|(?:(?:(?:(?:[0-9a-fA-F]){1,4}):){7,7}(?:(?:[0-9a-fA-F]){1,4}))'

  def __init__(self, argparser):
    ''' see base class' documentation on ``__init__`` '''
    super().__init__(argparser)
    self.pattern = compile_re(self.__class__.REGEXP, IGNORECASE)

  def process(self, line):
    ''' see base class' documentation on ``process`` '''

    for match in self.pattern.finditer(line):
      matched_string = match.group(0)
      segments = matched_string.split(':')

      for segment_i, segment in enumerate(reversed(segments)):
        if segment != '':
          segments[-1 - segment_i] = '0'
          break

      replace_string = ':'.join(segments)
      line = line.replace(matched_string, replace_string, 1)

    return line



@LineProcessorRegistry.register
class EmailProcessor(LineProcessorBase):
  '''
  anonymizes email addresses by replacing at least 50% of the characters
  in the local part and in the domain part
  '''

  # thanks to https://stackoverflow.com/a/201378
  REGEXP = r'(?:[a-z0-9!#$%&\'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&\'*+/=?^_`{|}~-]+)*|\"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(?:2(?:5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(?:2(?:5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])'

  @staticmethod
  def anonymize_string(string, max_ratio_to_keep=.5, keep_right=False):
    '''
    Anonymizes ``string`` by keeping ``max_ratio_to_keep`` characters
    and replacing the rest with '...'.
    By default, characters are removed from the end of the string
    (right), if ``keep_right`` evaluates to true, characters are removed
    from the beginning of ``string``.

    Returns the anonymized string.
    '''
    char_count = len(string)
    char_count_to_keep = int(char_count * max_ratio_to_keep)
    if keep_right:
      return '...' + string[-char_count_to_keep:]
    return string[:char_count_to_keep] + '...'

  def __init__(self, _):
    ''' see base class' documentation on ``__init__`` '''
    self.pattern = compile_re(self.__class__.REGEXP, IGNORECASE)

  def process(self, line):
    ''' see base class' documentation on ``process`` '''

    for match in self.pattern.finditer(line):
      matched_string = match.group(0)
      local_part, domain_part = matched_string.rsplit('@', 1)
      local_part = self.anonymize_string(local_part)
      domain_part = self.anonymize_string(domain_part, keep_right=True)
      replace_string = '%s@%s' % (local_part, domain_part)
      line = line.replace(matched_string, replace_string, 1)

    return line



def process_lines(in_file, out_file, processors):
  '''
  processes all lines with ``processors``,
  reads from ``in_file``, writes to ``out_file``
  '''

  info('processing lines')
  for line in in_file:
    try:
      decoded_line = line.decode()
    except UnicodeDecodeError:
      debug('could not decode byte from input; '
            'assuming input is binary; '
            'passing through rest of input')
      out_file.write(line)
      for pass_through_line in in_file:
        out_file.write(pass_through_line)
      break
    else:
      for processor in processors:
        decoded_line = processor.process(decoded_line)
      out_file.write(decoded_line.encode())



def get_in_file(args, cleaner):
  ''' returns the input file according to ``args`` '''

  debug('open input file "%s"', args.in_file)
  if args.in_file == '-':
    in_file = fdopen(stdin.fileno(), 'rb')
  else:
    in_file = open(args.in_file, 'rb')

  cleaner.add_job(in_file.close)
  return in_file



def get_out_file(args, cleaner):
  ''' returns the output file according to ``args`` '''

  if args.inplace:
    debug('create temporary file for in-place mode')
    out_file, args.out_file = mkstemp()
    cleaner.add_job(remove, args.out_file)

  debug('open output file "%s"' % args.out_file)

  if args.out_file == '-':
    out_file = fdopen(stdout.fileno(), 'wb')
  else:
    out_file = open(args.out_file, 'wb')

  cleaner.add_job(out_file.close)
  return out_file

def caught_main(cleaner):
  '''
  Actual main procedure.

  Uncaught exceptions will be handled in calling procedure.
  '''

  parser = argparse.ArgumentParser(
    description=__doc__,
    formatter_class=argparse.ArgumentDefaultsHelpFormatter
  )

  parser.add_argument('-d', '--debug', action='store_true', default=False,
                      help='turn on debug messages')
  parser.add_argument('-v', '--verbose', action='store_true', default=False,
                      help='turn on verbose messages')
  parser.add_argument('--inplace', action='store_true', default=False,
                      help='replace input file (out_file will be ignored)')
  parser.add_argument('in_file', nargs='?', default='-',
                      help='file to read from, stdin: -')
  parser.add_argument('out_file', nargs='?', default='-',
                      help='file to write to, stdout: -'),
  parser.add_argument('-m', '--modules', default=str.join(',',[l.__name__ for l in LineProcessorRegistry.items]),
                      help='comma separated list of modules to process' )


  # initialize processors
  processors = set(Processor(parser)
                   for Processor in LineProcessorRegistry.items)
  args = parser.parse_args()

  # set up logger
  logger = getLogger()
  logger.name = ""
  if args.debug:
    logger.setLevel(DEBUG)
  if args.verbose:
    logger.setLevel(INFO)

  debug('setting up processors')
  for processor in processors:
    debug('setting up %s', processor)
    processor.setup(args)

  # process only modules selected
  debug('create custom processor list')
  if args.modules:
    newp = processors.copy()
    em = vars(args)['modules'].split(',')
    debug('enabled modules: %s' % str.join(',',em))
    for p in newp:
      if type(p).__name__ not in em:
        debug('remove processor: %s' % type(p).__name__)
        processors.remove(p)

  in_file = get_in_file(args, cleaner)
  out_file = get_out_file(args, cleaner)

  debug('doing argument sanity checks')
  if args.inplace and in_file == stdin:
    error('Cannot modify stdin --inplace.')
    exit(1)

  process_lines(in_file, out_file, processors)

  cleaner.do_one_job() # closes out_file

  if args.inplace and in_file != stdin:
    assert out_file != stdout
    info('replacing input file')
    copy(out_file.name, in_file.name)

  info('all done')



def main():
  '''
  Wrapper around actual main procedure.

  Will hold back uncaught exceptions of the (actual) main procedure,
  will run clean up jobs, and will raise the held exception afterwards.
  '''

  cleaner = Cleaner()
  abnormal_termination = False
  try:
    caught_main(cleaner)
  except Exception as exception:
    error("abnormal termination (see error at end of output)")
    abnormal_termination = True
    raise exception
  finally:
    debug("running cleanup jobs")
    cleaner.do_all_jobs()

  if abnormal_termination:
    exit(1)
  else:
    debug("success - bye")



if __name__ == '__main__':
  main()
